<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Bhargav's Homepage - programming</title><link href="/" rel="alternate"></link><link href="/feeds/programming.atom.xml" rel="self"></link><id>/</id><updated>2012-03-31T12:12:00+05:30</updated><entry><title>Books To Read</title><link href="/books-to-read.html" rel="alternate"></link><published>2012-03-31T12:12:00+05:30</published><updated>2012-03-31T12:12:00+05:30</updated><author><name>Bhargav Bhat</name></author><id>tag:None,2012-03-31:/books-to-read.html</id><summary type="html">&lt;p&gt;My list of Books to Read&lt;/p&gt;</summary><content type="html">&lt;p&gt;After reading the Effective C++ book from Scott Meyers last year, I wanted to build a list of programming books, focused on C, C++ and UNIX/Linux that I wanted to read. This is that list in no particular order:&lt;/p&gt;
&lt;h3&gt;General&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;[x] Mythical Man Month&lt;/li&gt;
&lt;li&gt;[x] Code Complete&lt;/li&gt;
&lt;li&gt;[ ] Clean Coder&lt;/li&gt;
&lt;li&gt;[ ] Pragmatic Programmer&lt;/li&gt;
&lt;li&gt;[ ] Design Patterns (GoF book)&lt;/li&gt;
&lt;li&gt;[ ] Designing Object Oriented Software&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C/C++&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;[x] K&amp;amp;C C&lt;/li&gt;
&lt;li&gt;[x] C++ Programming Language&lt;/li&gt;
&lt;li&gt;[x] Effective C++&lt;/li&gt;
&lt;li&gt;[ ] More Effective C++&lt;/li&gt;
&lt;li&gt;[ ] Effective STL&lt;/li&gt;
&lt;li&gt;[ ] C++ Standard Template Library&lt;/li&gt;
&lt;li&gt;[ ] Algorithms in C++&lt;/li&gt;
&lt;li&gt;[ ] C++ FAQs&lt;/li&gt;
&lt;li&gt;[ ] Exceptional C++&lt;/li&gt;
&lt;li&gt;[ ] More Exceptional C++&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;UNIX/Linux&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;[ ] The Design of the UNIX Operating System&lt;/li&gt;
&lt;li&gt;[ ] Linux Kernel Development&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Misc&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;[ ] Scheme Programming Language&lt;/li&gt;
&lt;li&gt;[ ] Structure &amp;amp; Interpretation of Computer Programs&lt;/li&gt;
&lt;li&gt;[ ] Introduction to Algorithms &lt;/li&gt;
&lt;li&gt;[ ] Learning DCOM&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I don't intend to review or write about all of these books, maybe a few that I found the most impactful personally.&lt;/p&gt;</content><category term="programming"></category><category term="book-review"></category></entry><entry><title>Effective C++ : A Book Review</title><link href="/effective-c-a-book-review.html" rel="alternate"></link><published>2011-12-17T18:03:00+05:30</published><updated>2011-12-17T18:03:00+05:30</updated><author><name>Bhargav Bhat</name></author><id>tag:None,2011-12-17:/effective-c-a-book-review.html</id><summary type="html">&lt;p&gt;My review of the Effective C++ book&lt;/p&gt;</summary><content type="html">&lt;p&gt;With more of my day-to-day work moving to C++, I was looking for a nice book to help me get upto speed with C++, best practices and some of the gotchas that C++ is ~famous~ infamous for. This book in particular had rave reviews and was recommended by multiple people, with colleagues, former colleagues and internet strangers all saying very good things about it. I purchased by copy from Sapna Book House about 2 months ago and have been reading it on and off since. I just finished the last topic ("Item 55") a few hours ago.&lt;/p&gt;
&lt;p&gt;The copy I have with me is a 2008 reprint of the 3rd edition of this book (ISBN: 978-81-317-1480-5). The book is a paperback, printed paper is of good quality and highlighting does not ghost or show thru. No complaints on the paper or binding quality. The book has held up well.&lt;/p&gt;
&lt;p&gt;With regard to content, the book is divided into multiple sections and each section has a bunch of topics. Discussion is presented as an ordered list of "Item"s. 
This makes it very easy to pause and take a break between topics and get back to the book right after what you'd already read. 
Unfortunately, there weren't any exercises apart from a few teasers before gotchas that served as prompts for the reader to think things through and form a view before the "big reveal" of the gotcha and an explaination of why the compiler/language behaved the way it did. This was a deviation from perhaps some of the "textbook" style books that I had read so far, including K&amp;amp;R, which had really great compliment of thought provoking exercises.&lt;/p&gt;
&lt;p&gt;Of the 55 Items presented, the following were the most relevant to me, someone who was "migrating" to C++ from C:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Item 2  : Prefer &lt;code&gt;const&lt;/code&gt;s, &lt;code&gt;enum&lt;/code&gt;s and &lt;code&gt;inline&lt;/code&gt;s to &lt;code&gt;#define&lt;/code&gt;s &lt;/li&gt;
&lt;li&gt;Item 5  : Know what functions C++ silently writes and calls&lt;/li&gt;
&lt;li&gt;Item 8  : Prevent exceptions from leaving destructors&lt;/li&gt;
&lt;li&gt;Item 9  : Never call virtual fucntions during construction and destruction&lt;/li&gt;
&lt;li&gt;Item 14 : Think carefully about copying behaviour in resource managing classes&lt;/li&gt;
&lt;li&gt;Item 19 : Treat class design as type design&lt;/li&gt;
&lt;li&gt;Item 26 : Postpone variable definitions&lt;/li&gt;
&lt;li&gt;Item 27 : Minimize Casting&lt;/li&gt;
&lt;li&gt;Item 32 : Make sure public inheritance models "is-a"&lt;/li&gt;
&lt;li&gt;Item 41 : Understand implicit interfaces and compile-time polymorphism&lt;/li&gt;
&lt;li&gt;Item 48 : Be aware of template metaprogramming&lt;/li&gt;
&lt;li&gt;Item 54 : Familiarize yourself with the standard library&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The items were relatively independent that I could jump around the book and cover them in this order, having to refer back to other sections and items occasionally. This lent the book being a very easy read, although some of the material presented was a little tricky and I had to try a couple of short programs on my own to really "get" the material.&lt;/p&gt;
&lt;p&gt;Overall, I'd say the book lived up to the excellent reviews and positive feedback from colleagues and I would gladly recommend it to someone in my shoes :). I would definitely consider reading more books from Scott Meyers. viz. : More Effective C++ and Effective STL which I understand are presented in a similar format and cover much of the same material. &lt;/p&gt;</content><category term="programming"></category><category term="cpp"></category><category term="book-review"></category></entry><entry><title>The Hashes</title><link href="/the-hashes.html" rel="alternate"></link><published>2011-10-08T13:22:00+05:30</published><updated>2011-10-08T13:22:00+05:30</updated><author><name>Bhargav Bhat</name></author><id>tag:None,2011-10-08:/the-hashes.html</id><summary type="html">&lt;p&gt;TIL about the # (Stringizing) and ## (Concatenation) operators of the Pre-processor&lt;/p&gt;</summary><content type="html">&lt;p&gt;I ran into a seemingly straight forward problem earlier this week: treat a particular &lt;code&gt;#define&lt;/code&gt; value as either string or int, depending on the context where it is used. A naive solution to is repeating the &lt;code&gt;#define&lt;/code&gt; twice, once as a string and then as a integer:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#define SOME_VALUE_INT 42&lt;/span&gt;
&lt;span class="cp"&gt;#define SOME_VALUE_STR &amp;quot;42&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;... and using the right value depending on the context. Not only is this naive method a violation of DRY, but it is also very crude and inelegant. Having multiple such &lt;code&gt;#define&lt;/code&gt;ed constants are a maintainance disaster waiting to happen. My search for a better way to deal with this lead me to a very relevant &lt;a href="https://stackoverflow.com/questions/2653214/stringification-of-a-macro-value"&gt;question&lt;/a&gt; on SO and down I went the rabbit hole that is the the C Pre-processor. This is a summary of my learning and notes for my future self.&lt;/p&gt;
&lt;h3&gt;The Stringizing Operator : &lt;code&gt;#&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;This operator solves the problem above rather elegantly, as described the accepted answer to in the SO question above:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#define xstr(a) str(a)&lt;/span&gt;
&lt;span class="cp"&gt;#define str(a) #a&lt;/span&gt;

&lt;span class="cp"&gt;#define RECORDS_PER_PAGE 10&lt;/span&gt;

&lt;span class="cp"&gt;#define REQUEST_RECORDS \&lt;/span&gt;
&lt;span class="cp"&gt;        &amp;quot;SELECT Fields FROM Table WHERE Conditions&amp;quot; \&lt;/span&gt;
&lt;span class="cp"&gt;        &amp;quot; OFFSET %d * &amp;quot; xstr(RECORDS_PER_PAGE) \&lt;/span&gt;
&lt;span class="cp"&gt;        &amp;quot; LIMIT &amp;quot; xstr(RECORDS_PER_PAGE) &amp;quot;;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The &lt;code&gt;#&lt;/code&gt; operator:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allows the preprocessor to replace anything prefixed with a &lt;code&gt;#&lt;/code&gt; with the literal text of the actual argument. The argument is not macro-expanded.&lt;/li&gt;
&lt;li&gt;leading &amp;amp; trailing whitespace is ignored. Whitespaces in the middle of the text converted to a single space&lt;/li&gt;
&lt;li&gt;to stringize the result of expansion of a macro argument, you have to use two levels of macros&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Source&lt;/em&gt; : GCC &lt;a href="https://gcc.gnu.org/onlinedocs/cpp/Stringizing.html#Stringizing"&gt;docs&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;The Concatenation Operator : &lt;code&gt;##&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;This operator solves a somewhate related problem of merging or combining two macro values into a single string. The &lt;code&gt;##&lt;/code&gt; operator:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;performs token pasting : two tokens on either side of ‘##’ operator are combined into a single token. The the actual arguments are not macro-expanded.&lt;/li&gt;
&lt;li&gt;cannot create a comment by concatenating ‘/’ and ‘*’.&lt;/li&gt;
&lt;li&gt;comments in arguments that will be concatenated&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Source&lt;/em&gt; : GCC &lt;a href="https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html#Concatenation"&gt;docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;While these operators present interesting possibilities, using them for all but the most basic and straight forward needs would be difficult. Although handy in a few situations, they are qutie limited and come with a bunch of caveats. However, there still are a few corner cases where they do make lives of programmers a lot simpler.&lt;/p&gt;</content><category term="programming"></category><category term="c"></category><category term="preprocessor"></category><category term="til"></category></entry></feed>